//SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import {SNARK_SCALAR_FIELD} from "./SemaphoreConstants.sol";
import "../interfaces/ISemaphoreGroups.sol";
import "@zk-kit/incremental-merkle-tree.sol/IncrementalBinaryTree.sol";
import "@openzeppelin/contracts/utils/Context.sol";

/// @title Semaphore groups contract.
/// @dev The following code allows you to create groups, add and remove members.
/// You can use getters to obtain informations about groups (root, depth, number of leaves).
abstract contract SemaphoreGroups is Context, ISemaphoreGroups {
    /// @dev Gets a group id and returns the root.
    mapping(uint256 => uint256) internal roots;
    /// @dev Depth of the merkle tree.
    mapping(uint256 => uint256) internal depths;

    /// @dev Creates a new group by setting the merkle root of the tree.
    /// @param groupId: Id of the group.
    /// @param merkleTreeRoot: Merkle tree root.
    /// @param merkleTreeDepth: Merkle tree depth.
    /// @param zeroValue: Zero value of the tree.
    function _createGroup(
        uint256 groupId,
        uint256 merkleTreeRoot,
        uint256 merkleTreeDepth,
        uint256 zeroValue
    ) internal virtual {
        if (groupId >= SNARK_SCALAR_FIELD) {
            revert Semaphore__GroupIdIsNotLessThanSnarkScalarField();
        }

        roots[groupId] = merkleTreeRoot;
        depths[groupId] = merkleTreeDepth;
        
        emit GroupCreated(groupId, merkleTreeDepth, zeroValue);
    }

    // /// @dev Adds an identity commitment to an existing group.
    // /// @param groupId: Id of the group.
    // /// @param identityCommitment: New identity commitment.
    // function _addMember(uint256 groupId, uint256 identityCommitment) internal virtual {
    //     if (getMerkleTreeDepth(groupId) == 0) {
    //         revert Semaphore__GroupDoesNotExist();
    //     }

    //     merkleTree[groupId].insert(identityCommitment);

    //     uint256 merkleTreeRoot = getMerkleTreeRoot(groupId);
    //     uint256 index = getNumberOfMerkleTreeLeaves(groupId) - 1;

    //     emit MemberAdded(groupId, index, identityCommitment, merkleTreeRoot);
    // }

    // /// @dev Updates an identity commitment of an existing group. A proof of membership is
    // /// needed to check if the node to be updated is part of the tree.
    // /// @param groupId: Id of the group.
    // /// @param identityCommitment: Existing identity commitment to be updated.
    // /// @param newIdentityCommitment: New identity commitment.
    // /// @param proofSiblings: Array of the sibling nodes of the proof of membership.
    // /// @param proofPathIndices: Path of the proof of membership.
    // function _updateMember(
    //     uint256 groupId,
    //     uint256 identityCommitment,
    //     uint256 newIdentityCommitment,
    //     uint256[] calldata proofSiblings,
    //     uint8[] calldata proofPathIndices
    // ) internal virtual {
    //     if (getMerkleTreeRoot(groupId) == 0) {
    //         revert Semaphore__GroupDoesNotExist();
    //     }

    //     merkleTree[groupId].update(identityCommitment, newIdentityCommitment, proofSiblings, proofPathIndices);

    //     uint256 merkleTreeRoot = getMerkleTreeRoot(groupId);
    //     uint256 index = proofPathIndicesToMemberIndex(proofPathIndices);

    //     emit MemberUpdated(groupId, index, identityCommitment, newIdentityCommitment, merkleTreeRoot);
    // }

    // /// @dev Removes an identity commitment from an existing group. A proof of membership is
    // /// needed to check if the node to be deleted is part of the tree.
    // /// @param groupId: Id of the group.
    // /// @param identityCommitment: Existing identity commitment to be removed.
    // /// @param proofSiblings: Array of the sibling nodes of the proof of membership.
    // /// @param proofPathIndices: Path of the proof of membership.
    // function _removeMember(
    //     uint256 groupId,
    //     uint256 identityCommitment,
    //     uint256[] calldata proofSiblings,
    //     uint8[] calldata proofPathIndices
    // ) internal virtual {
    //     if (getMerkleTreeRoot(groupId) == 0) {
    //         revert Semaphore__GroupDoesNotExist();
    //     }

    //     merkleTree[groupId].remove(identityCommitment, proofSiblings, proofPathIndices);

    //     uint256 merkleTreeRoot = getMerkleTreeRoot(groupId);
    //     uint256 index = proofPathIndicesToMemberIndex(proofPathIndices);

    //     emit MemberRemoved(groupId, index, identityCommitment, merkleTreeRoot);
    // }

    /// @dev See {ISemaphoreGroups-getMerkleTreeRoot}.
    function getMerkleTreeRoot(uint256 groupId) public view virtual override returns (uint256) {
        return roots[groupId];
    }

    /// @dev See {ISemaphoreGroups-getMerkleTreeDepth}.
    function getMerkleTreeDepth(uint256 groupId) public view virtual override returns (uint256) {
        return depths[groupId];
    }

    // /// @dev See {ISemaphoreGroups-getNumberOfMerkleTreeLeaves}.
    // function getNumberOfMerkleTreeLeaves(uint256 groupId) public view virtual override returns (uint256) {
    //     return merkleTree[groupId].numberOfLeaves;
    // }

    // /// @dev Converts the path indices of a Merkle proof to the identity commitment index in the tree.
    // /// @param proofPathIndices: Path of the proof of membership.
    // /// @return Index of a group member.
    // function proofPathIndicesToMemberIndex(uint8[] calldata proofPathIndices) private pure returns (uint256) {
    //     uint256 memberIndex = 0;

    //     for (uint8 i = uint8(proofPathIndices.length); i > 0; ) {
    //         if (memberIndex > 0 || proofPathIndices[i - 1] != 0) {
    //             memberIndex *= 2;

    //             if (proofPathIndices[i - 1] == 1) {
    //                 memberIndex += 1;
    //             }
    //         }

    //         unchecked {
    //             --i;
    //         }
    //     }

    //     return memberIndex;
    // }
}

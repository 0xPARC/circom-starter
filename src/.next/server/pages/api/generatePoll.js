"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/generatePoll";
exports.ids = ["pages/api/generatePoll"];
exports.modules = {

/***/ "@prisma/client":
/*!*********************************!*\
  !*** external "@prisma/client" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("@prisma/client");

/***/ }),

/***/ "circomlibjs":
/*!******************************!*\
  !*** external "circomlibjs" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("circomlibjs");

/***/ }),

/***/ "(api)/./lib/prisma.ts":
/*!***********************!*\
  !*** ./lib/prisma.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prisma/client */ \"@prisma/client\");\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prisma_client__WEBPACK_IMPORTED_MODULE_0__);\n\nlet prisma;\nprisma = new _prisma_client__WEBPACK_IMPORTED_MODULE_0__.PrismaClient();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (prisma);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9saWIvcHJpc21hLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBRUEsSUFBSUMsTUFBSjtBQUVBQSxNQUFNLEdBQUcsSUFBSUQsd0RBQUosRUFBVDtBQUVBLGlFQUFlQyxNQUFmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3JjLy4vbGliL3ByaXNtYS50cz85ODIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByaXNtYUNsaWVudCB9IGZyb20gJ0BwcmlzbWEvY2xpZW50JztcblxubGV0IHByaXNtYTogUHJpc21hQ2xpZW50O1xuXG5wcmlzbWEgPSBuZXcgUHJpc21hQ2xpZW50KCk7XG5cbmV4cG9ydCBkZWZhdWx0IHByaXNtYTsiXSwibmFtZXMiOlsiUHJpc21hQ2xpZW50IiwicHJpc21hIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/prisma.ts\n");

/***/ }),

/***/ "(api)/./pages/api/generatePoll.ts":
/*!***********************************!*\
  !*** ./pages/api/generatePoll.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _helpers_merkle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/merkle */ \"(api)/./pages/api/helpers/merkle.ts\");\n// Next.js API route support: https://nextjs.org/docs/api-routes/introduction\n\n/** \n * @description: This is the API endpoint for generating and storing a poll in the DB.\n*/\n\n\n/** \n * @function: handler\n * @description: This is the handler for the API endpoint.\n * @param {string} req.body.data.title - The title of the poll.\n * @param {[]string} req.body.data.addresses - The addresses that can vote in the poll.\n * @param {string} req.body.data.description - The description of the poll.\n * @param {string} req.body.data.groupDescription - The description of the group.\n * @param {number} req.body.data.createdAt - The time the poll was created.\n * @param {number} req.body.data.deadline - The deadline of the poll.\n */\nasync function handler(req, res) {\n  if (req.method !== 'POST') {\n    res.status(405).json({\n      name: \"POST endpoint!\",\n      rootHash: \"\",\n      pollId: -1,\n      title: \"\",\n      deadline: -1\n    });\n  }\n\n  if (typeof req.body == 'string') {\n    var body = JSON.parse(req.body);\n  } else {\n    var body = req.body;\n  }\n\n  if (\"data\" in body == false) {\n    res.status(400).json({\n      name: \"No data!\",\n      rootHash: \"\",\n      pollId: -1,\n      title: \"\",\n      deadline: -1\n    });\n  }\n\n  var data = body.data;\n  var title, description, groupDescription, createdAt, deadline, addresses; // Required fields!\n\n  if (\"title\" in data == false) {\n    res.status(400).json({\n      name: \"Add a title!\",\n      rootHash: \"\",\n      pollId: -1,\n      title: \"\",\n      deadline: -1\n    });\n  } else {\n    title = data.title;\n  }\n\n  if (\"addresses\" in data == false) {\n    res.status(400).json({\n      name: \"Must have some addresses!\",\n      rootHash: \"\",\n      pollId: -1,\n      title: \"\",\n      deadline: -1\n    });\n  } else {\n    addresses = data.addresses;\n  }\n\n  if (\"description\" in data == false) {\n    description = \"\";\n  } else {\n    description = data.description;\n  }\n\n  if (\"groupDescription\" in data == false) {\n    groupDescription = \"\";\n  } else {\n    groupDescription = data.groupDescription;\n  }\n\n  if (\"createdAt\" in data == false) {\n    createdAt = Date.now();\n  } else {\n    createdAt = data.createdAt;\n  }\n\n  if (\"deadline\" in data == false) {\n    // Fix: Set time to 1 hour from now\n    var myDate = new Date();\n    myDate.setUTCHours(myDate.getUTCHours() + 1);\n    deadline = myDate.getTime();\n  } else {\n    deadline = data.deadline;\n  }\n\n  console.log(\"Parsed Correctly: \", title, description, groupDescription, createdAt, deadline, addresses);\n  var pollData = await (0,_helpers_merkle__WEBPACK_IMPORTED_MODULE_0__.storePoll)(title, description, groupDescription, createdAt, deadline, addresses);\n  res.status(200).json({\n    name: \"Success!\",\n    rootHash: pollData.rootHash,\n    pollId: pollData.pollId,\n    title: title,\n    deadline: deadline\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVMsR0FBR0UsSUFBSSxDQUFDQyxHQUFMLEVBQVo7RUFDRCxDQUZELE1BRU87SUFDTEgsU0FBUyxHQUFHSCxJQUFJLENBQUNHLFNBQWpCO0VBQ0Q7O0VBQ0QsSUFBSSxjQUFjSCxJQUFkLElBQXNCLEtBQTFCLEVBQWlDO0lBQy9CO0lBQ0EsSUFBSU8sTUFBTSxHQUFHLElBQUlGLElBQUosRUFBYjtJQUNBRSxNQUFNLENBQUNDLFdBQVAsQ0FBbUJELE1BQU0sQ0FBQ0UsV0FBUCxLQUF1QixDQUExQztJQUNBYixRQUFRLEdBQUdXLE1BQU0sQ0FBQ0csT0FBUCxFQUFYO0VBQ0QsQ0FMRCxNQUtPO0lBQ0xkLFFBQVEsR0FBR0ksSUFBSSxDQUFDSixRQUFoQjtFQUNEOztFQUNEZSxPQUFPLENBQUNDLEdBQVIsQ0FBWSxvQkFBWixFQUFrQ2pCLEtBQWxDLEVBQXlDTSxXQUF6QyxFQUFzREMsZ0JBQXRELEVBQXdFQyxTQUF4RSxFQUFtRlAsUUFBbkYsRUFBNkZRLFNBQTdGO0VBRUEsSUFBSVMsUUFBUSxHQUFHLE1BQU01QiwwREFBUyxDQUFDVSxLQUFELEVBQVFNLFdBQVIsRUFBcUJDLGdCQUFyQixFQUF1Q0MsU0FBdkMsRUFBa0RQLFFBQWxELEVBQTREUSxTQUE1RCxDQUE5QjtFQUVBaEIsR0FBRyxDQUFDRSxNQUFKLENBQVcsR0FBWCxFQUFnQkMsSUFBaEIsQ0FBcUI7SUFBRUMsSUFBSSxFQUFFLFVBQVI7SUFBb0JDLFFBQVEsRUFBRW9CLFFBQVEsQ0FBQ3BCLFFBQXZDO0lBQWlEQyxNQUFNLEVBQUVtQixRQUFRLENBQUNuQixNQUFsRTtJQUEwRUMsS0FBSyxFQUFFQSxLQUFqRjtJQUF3RkMsUUFBUSxFQUFFQTtFQUFsRyxDQUFyQjtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3JjLy4vcGFnZXMvYXBpL2dlbmVyYXRlUG9sbC50cz8zMDE4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIE5leHQuanMgQVBJIHJvdXRlIHN1cHBvcnQ6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yb3V0ZXMvaW50cm9kdWN0aW9uXG5cbi8qKiBcbiAqIEBkZXNjcmlwdGlvbjogVGhpcyBpcyB0aGUgQVBJIGVuZHBvaW50IGZvciBnZW5lcmF0aW5nIGFuZCBzdG9yaW5nIGEgcG9sbCBpbiB0aGUgREIuXG4qL1xuXG5pbXBvcnQgdHlwZSB7IE5leHRBcGlSZXF1ZXN0LCBOZXh0QXBpUmVzcG9uc2UgfSBmcm9tICduZXh0J1xuaW1wb3J0IHtzdG9yZVBvbGx9IGZyb20gJy4vaGVscGVycy9tZXJrbGUnXG5pbXBvcnQgcHJpc21hIGZyb20gJy4uLy4uL2xpYi9wcmlzbWEnXG5pbXBvcnQgeyBQcmlzbWEgfSBmcm9tICdAcHJpc21hL2NsaWVudCdcblxudHlwZSBEYXRhID0ge1xuICBuYW1lOiBzdHJpbmdcbiAgcm9vdEhhc2g6IHN0cmluZ1xuICBwb2xsSWQ6IG51bWJlclxuICB0aXRsZTogc3RyaW5nXG4gIGRlYWRsaW5lOiBudW1iZXJcbn1cblxuLyoqIFxuICogQGZ1bmN0aW9uOiBoYW5kbGVyXG4gKiBAZGVzY3JpcHRpb246IFRoaXMgaXMgdGhlIGhhbmRsZXIgZm9yIHRoZSBBUEkgZW5kcG9pbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxLmJvZHkuZGF0YS50aXRsZSAtIFRoZSB0aXRsZSBvZiB0aGUgcG9sbC5cbiAqIEBwYXJhbSB7W11zdHJpbmd9IHJlcS5ib2R5LmRhdGEuYWRkcmVzc2VzIC0gVGhlIGFkZHJlc3NlcyB0aGF0IGNhbiB2b3RlIGluIHRoZSBwb2xsLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlcS5ib2R5LmRhdGEuZGVzY3JpcHRpb24gLSBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIHBvbGwuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxLmJvZHkuZGF0YS5ncm91cERlc2NyaXB0aW9uIC0gVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBncm91cC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXEuYm9keS5kYXRhLmNyZWF0ZWRBdCAtIFRoZSB0aW1lIHRoZSBwb2xsIHdhcyBjcmVhdGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlcS5ib2R5LmRhdGEuZGVhZGxpbmUgLSBUaGUgZGVhZGxpbmUgb2YgdGhlIHBvbGwuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIoXG4gIHJlcTogTmV4dEFwaVJlcXVlc3QsXG4gIHJlczogTmV4dEFwaVJlc3BvbnNlPERhdGE+XG4pIHtcbiAgaWYgKHJlcS5tZXRob2QgIT09ICdQT1NUJykge1xuICAgIHJlcy5zdGF0dXMoNDA1KS5qc29uKHtcbiAgICAgIG5hbWU6IFwiUE9TVCBlbmRwb2ludCFcIiwgcm9vdEhhc2g6IFwiXCIsIHBvbGxJZDogLTEsIHRpdGxlOiBcIlwiLCBkZWFkbGluZTogLTFcbiAgICB9KVxuICB9XG4gIGlmICh0eXBlb2YgcmVxLmJvZHkgPT0gJ3N0cmluZycpIHtcbiAgICB2YXIgYm9keSA9IEpTT04ucGFyc2UocmVxLmJvZHkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIGJvZHkgPSByZXEuYm9keVxuICB9XG4gIGlmIChcImRhdGFcIiBpbiBib2R5ID09IGZhbHNlKSB7XG4gICAgcmVzLnN0YXR1cyg0MDApLmpzb24oe1xuICAgICAgbmFtZTogXCJObyBkYXRhIVwiLCByb290SGFzaDogXCJcIiwgcG9sbElkOiAtMSwgdGl0bGU6IFwiXCIsIGRlYWRsaW5lOiAtMVxuICAgIH0pXG4gIH1cbiAgdmFyIGRhdGEgPSBib2R5LmRhdGFcblxuXG4gIHZhciB0aXRsZSwgZGVzY3JpcHRpb24sIGdyb3VwRGVzY3JpcHRpb24sIGNyZWF0ZWRBdCwgZGVhZGxpbmUsIGFkZHJlc3Nlc1xuXG4gIC8vIFJlcXVpcmVkIGZpZWxkcyFcbiAgaWYgKFwidGl0bGVcIiBpbiBkYXRhID09IGZhbHNlKSB7XG4gICAgcmVzLnN0YXR1cyg0MDApLmpzb24oe1xuICAgICAgbmFtZTogXCJBZGQgYSB0aXRsZSFcIiwgcm9vdEhhc2g6IFwiXCIsIHBvbGxJZDogLTEsIHRpdGxlOiBcIlwiLCBkZWFkbGluZTogLTFcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHRpdGxlID0gZGF0YS50aXRsZVxuICB9XG4gIGlmIChcImFkZHJlc3Nlc1wiIGluIGRhdGEgPT0gZmFsc2UpIHtcbiAgICByZXMuc3RhdHVzKDQwMCkuanNvbih7XG4gICAgICBuYW1lOiBcIk11c3QgaGF2ZSBzb21lIGFkZHJlc3NlcyFcIiwgcm9vdEhhc2g6IFwiXCIsIHBvbGxJZDogLTEsIHRpdGxlOiBcIlwiLCBkZWFkbGluZTogLTFcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGFkZHJlc3NlcyA9IGRhdGEuYWRkcmVzc2VzXG4gIH1cblxuICBpZiAoXCJkZXNjcmlwdGlvblwiIGluIGRhdGEgPT0gZmFsc2UpIHtcbiAgICBkZXNjcmlwdGlvbiA9IFwiXCJcbiAgfSBlbHNlIHtcbiAgICBkZXNjcmlwdGlvbiA9IGRhdGEuZGVzY3JpcHRpb25cbiAgfVxuICBpZiAoXCJncm91cERlc2NyaXB0aW9uXCIgaW4gZGF0YSA9PSBmYWxzZSkge1xuICAgIGdyb3VwRGVzY3JpcHRpb24gPSBcIlwiXG4gIH0gZWxzZSB7XG4gICAgZ3JvdXBEZXNjcmlwdGlvbiA9IGRhdGEuZ3JvdXBEZXNjcmlwdGlvblxuICB9XG4gIGlmIChcImNyZWF0ZWRBdFwiIGluIGRhdGEgPT0gZmFsc2UpIHtcbiAgICBjcmVhdGVkQXQgPSBEYXRlLm5vdygpXG4gIH0gZWxzZSB7XG4gICAgY3JlYXRlZEF0ID0gZGF0YS5jcmVhdGVkQXRcbiAgfVxuICBpZiAoXCJkZWFkbGluZVwiIGluIGRhdGEgPT0gZmFsc2UpIHtcbiAgICAvLyBGaXg6IFNldCB0aW1lIHRvIDEgaG91ciBmcm9tIG5vd1xuICAgIHZhciBteURhdGUgPSBuZXcgRGF0ZSgpXG4gICAgbXlEYXRlLnNldFVUQ0hvdXJzKG15RGF0ZS5nZXRVVENIb3VycygpICsgMSlcbiAgICBkZWFkbGluZSA9IG15RGF0ZS5nZXRUaW1lKClcbiAgfSBlbHNlIHtcbiAgICBkZWFkbGluZSA9IGRhdGEuZGVhZGxpbmVcbiAgfVxuICBjb25zb2xlLmxvZyhcIlBhcnNlZCBDb3JyZWN0bHk6IFwiLCB0aXRsZSwgZGVzY3JpcHRpb24sIGdyb3VwRGVzY3JpcHRpb24sIGNyZWF0ZWRBdCwgZGVhZGxpbmUsIGFkZHJlc3NlcylcblxuICB2YXIgcG9sbERhdGEgPSBhd2FpdCBzdG9yZVBvbGwodGl0bGUsIGRlc2NyaXB0aW9uLCBncm91cERlc2NyaXB0aW9uLCBjcmVhdGVkQXQsIGRlYWRsaW5lLCBhZGRyZXNzZXMpXG4gIFxuICByZXMuc3RhdHVzKDIwMCkuanNvbih7IG5hbWU6IFwiU3VjY2VzcyFcIiwgcm9vdEhhc2g6IHBvbGxEYXRhLnJvb3RIYXNoLCBwb2xsSWQ6IHBvbGxEYXRhLnBvbGxJZCwgdGl0bGU6IHRpdGxlLCBkZWFkbGluZTogZGVhZGxpbmUgfSlcbn1cbiJdLCJuYW1lcyI6WyJzdG9yZVBvbGwiLCJoYW5kbGVyIiwicmVxIiwicmVzIiwibWV0aG9kIiwic3RhdHVzIiwianNvbiIsIm5hbWUiLCJyb290SGFzaCIsInBvbGxJZCIsInRpdGxlIiwiZGVhZGxpbmUiLCJib2R5IiwiSlNPTiIsInBhcnNlIiwiZGF0YSIsImRlc2NyaXB0aW9uIiwiZ3JvdXBEZXNjcmlwdGlvbiIsImNyZWF0ZWRBdCIsImFkZHJlc3NlcyIsIkRhdGUiLCJub3ciLCJteURhdGUiLCJzZXRVVENIb3VycyIsImdldFVUQ0hvdXJzIiwiZ2V0VGltZSIsImNvbnNvbGUiLCJsb2ciLCJwb2xsRGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./pages/api/generatePoll.ts\n");

/***/ }),

/***/ "(api)/./pages/api/helpers/merkle.ts":
/*!*************************************!*\
  !*** ./pages/api/helpers/merkle.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getSiblingsAndPathIndices\": () => (/* binding */ getSiblingsAndPathIndices),\n/* harmony export */   \"storePoll\": () => (/* binding */ storePoll),\n/* harmony export */   \"verifyAddressInTree\": () => (/* binding */ verifyAddressInTree)\n/* harmony export */ });\n/* harmony import */ var _lib_prisma__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/prisma */ \"(api)/./lib/prisma.ts\");\n/* harmony import */ var _merklePoseidon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./merklePoseidon */ \"(api)/./pages/api/helpers/merklePoseidon.ts\");\n\n\n// const buildPoseidon = require(\"circomlibjs\").buildPoseidon;\n// /**\n//  * Custom poseidon hash function that hashes strings.\n//  * @returns {Promise<Function>} poseidon - The poseidon hash function.\n//  */\n// const buildCustomPoseidon = async (): Promise<Function> => {\n//     const poseidon = await buildPoseidon();\n//     return (x: string[]) => {\n//         const hashString = poseidon.F.toString(poseidon(x));\n//         // console.log(parseInt(hashString).toString(16))\n//         // const hexOfString = Buffer.from(x, 'utf8').toString('hex');\n//         // const bigIntOfString = BigInt(\"0x\" + hexOfString);\n//         // const poseidonHashOutput = poseidon([bigIntOfString]);\n//         // console.log(poseidonHashOutput);\n//         // console.log(parseInt(poseidon.F.toString(poseidonHashOutput)).toString(16))\n//         // return poseidonHashOutput;\n//         return hashString\n//     }\n// }\n\n/** \n * @function: storePoll\n * @description: This function creates a merkle tree and stores the result inside of the database.\n * @returns {BigInt} root - The root hash of the merkle tree created.\n * @returns {number} pollId - The poll id of the poll that was created.\n */\nasync function storePoll(title, description, groupDescription, createdAt, deadline, addresses) {\n  var title = title;\n  var description = description;\n  var groupDescription = groupDescription;\n  var dateCreatedAt = new Date(createdAt);\n  var dateDeadline = new Date(deadline); // TODO: CONFIRM THAT ADDRESSES ARE VALID (Molly will probs take care of this) Yep\n  // Import poseidon hash function\n  // const poseidon = await buildCustomPoseidon();\n  // const poseidon = await buildPoseidon();\n  // Handles arbitrary input!\n\n  var tree = await (0,_merklePoseidon__WEBPACK_IMPORTED_MODULE_1__.buildTreePoseidon)(addresses);\n  console.log(tree.root);\n  var rootString = tree.root.toString(); // var root = tree.getRoot().toString('hex')\n\n  var poll = await _lib_prisma__WEBPACK_IMPORTED_MODULE_0__[\"default\"].poll.create({\n    data: {\n      title: title,\n      description: description,\n      groupDescription: groupDescription,\n      createdAt: dateCreatedAt,\n      deadline: dateDeadline,\n      tree: {\n        create: {\n          rootHash: rootString,\n          leaves: addresses\n        }\n      }\n    }\n  }); // TODO: CONTRACT CALL TO CREATE POLL IN CONTRACT\n  // const allPolls = await prisma.poll.findMany({\n  //     include: {\n  //       tree: true,\n  //     },\n  // })\n  // Print all polls!\n  // console.dir(allPolls, { depth: null })\n\n  return {\n    rootHash: rootString,\n    pollId: poll.id\n  };\n}\n/** \n * @function: verifyAddressInTree\n * @description: This function verifies if an address is in a merkle tree.\n * @returns {boolean} isValidPollId - Whether or not the poll id is valid.\n * @returns {number} inTree - Whether or not the address is in the tree.\n */\n\nasync function verifyAddressInTree(address, pollId) {\n  const data = await getTreeFromPollId(pollId);\n\n  if (data.tree == null) {\n    return {\n      isValidPollId: false,\n      inTree: false\n    };\n  }\n\n  var tree = data.tree;\n  var merkleTree = await (0,_merklePoseidon__WEBPACK_IMPORTED_MODULE_1__.buildTreePoseidon)(tree.leaves);\n  var BigIntAddress = BigInt(address).toString();\n  var inTree = await (0,_merklePoseidon__WEBPACK_IMPORTED_MODULE_1__.verifyInTree)(merkleTree.root.toString(), address, merkleTree.leafToPathElements[BigIntAddress], merkleTree.leafToPathIndices[BigIntAddress]); // console.log(\"inTree\", inTree)\n  // var inTree = merkleTree.verify(proof, address, merkleTree.getRoot())\n\n  return {\n    isValidPollId: true,\n    inTree: inTree\n  };\n}\n/** \n * @function: getSiblingsAndPathIndices\n * @description: This function gets the siblings and path indices of an address in a merkle tree for the verifier & generator.\n * @returns {boolean} isValidPollId - Whether or not the poll id is valid.\n * @returns {[]string} siblings - The siblings of the address in the merkle tree.\n * @returns {[]number} pathIndices - The path indices of the siblings {0, 1} (sibling on right, sibling on left).\n */\n\nasync function getSiblingsAndPathIndices(address, pollId) {\n  const data = await getTreeFromPollId(pollId);\n\n  if (data.tree == null) {\n    return {\n      isValidPollId: false,\n      siblings: [],\n      pathIndices: []\n    };\n  }\n\n  var tree = data.tree;\n  var merkleTree = await (0,_merklePoseidon__WEBPACK_IMPORTED_MODULE_1__.buildTreePoseidon)(tree.leaves);\n  console.log(merkleTree.leafToPathElements);\n  console.log(merkleTree.leafToPathIndices); // const proof = merkleTree.getProof(address)\n  // var siblings = []\n  // var pathIndices = []\n  // for (var i = 0; i < proof.length; i++) {\n  //     var siblingHash = proof[i].data.toString('hex')\n  //     siblings.push(siblingHash)\n  //     // If left 0, if right 1\n  //     var pathIndex = proof[i].position == 'left' ? 1 : 0\n  //     pathIndices.push(pathIndex)\n  // }\n\n  var siblings = []; // console.log(await merkleTree.leafToPathIndices.length)\n  // console.log(merkleTree.leafToPathElements[address])\n\n  var BigIntAddress = BigInt(address).toString();\n  console.log(BigIntAddress);\n  var BigIntSiblings = merkleTree.leafToPathElements[BigIntAddress];\n  console.log(BigIntSiblings);\n\n  for (var i = 0; i < BigIntSiblings.length; i++) {\n    siblings.push(BigIntSiblings[i].toString());\n  }\n\n  return {\n    isValidPollId: true,\n    siblings: siblings,\n    pathIndices: merkleTree.leafToPathIndices[BigIntAddress]\n  };\n}\n/** \n * @function: getSiblingsAndPathIndices\n * @description: This function gets the siblings and path indices of an address in a merkle tree for the verifier & generator.\n * @returns {number} pollId - Poll id of the poll that was created.\n * @returns {[]string} tree - The merkle tree that was created.\n */\n\nasync function getTreeFromPollId(pollId) {\n  const tree = await _lib_prisma__WEBPACK_IMPORTED_MODULE_0__[\"default\"].merkleTree.findUnique({\n    where: {\n      id: pollId\n    }\n  }); // Print all polls!\n  // console.dir(tree, { depth: null })\n\n  return {\n    tree: tree,\n    pollId: pollId\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUFBZDtFQUNEOztFQUNELE9BQU87SUFBQ1csYUFBYSxFQUFFLElBQWhCO0lBQXNCUSxRQUFRLEVBQUVBLFFBQWhDO0lBQTBDQyxXQUFXLEVBQUVQLFVBQVUsQ0FBQ0ksaUJBQVgsQ0FBNkJILGFBQTdCO0VBQXZELENBQVA7QUFDSDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxlQUFlSixpQkFBZixDQUFpQ0osTUFBakMsRUFBaUQ7RUFFN0MsTUFBTVgsSUFBSSxHQUFHLE1BQU1iLHlFQUFBLENBQTZCO0lBQzVDNEMsS0FBSyxFQUFFO01BQ0huQixFQUFFLEVBQUVEO0lBREQ7RUFEcUMsQ0FBN0IsQ0FBbkIsQ0FGNkMsQ0FPN0M7RUFDQTs7RUFFQSxPQUFPO0lBQUNYLElBQUksRUFBRUEsSUFBUDtJQUFhVyxNQUFNLEVBQUVBO0VBQXJCLENBQVA7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL3NyYy8uL3BhZ2VzL2FwaS9oZWxwZXJzL21lcmtsZS50cz8yMmQwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwcmlzbWEgZnJvbSAnLi4vLi4vLi4vbGliL3ByaXNtYSc7XG5pbXBvcnQgeyBNZXJrbGVUcmVlIH0gZnJvbSAnbWVya2xldHJlZWpzJ1xuaW1wb3J0IGtlY2NhazI1NiBmcm9tICdrZWNjYWsyNTYnXG5pbXBvcnQgeyBidWlsZFRyZWVQb3NlaWRvbiwgdmVyaWZ5SW5UcmVlIH0gZnJvbSAnLi9tZXJrbGVQb3NlaWRvbic7XG5pbXBvcnQgYnVpbGQgZnJvbSAnbmV4dC9kaXN0L2J1aWxkJztcbi8vIGNvbnN0IGJ1aWxkUG9zZWlkb24gPSByZXF1aXJlKFwiY2lyY29tbGlianNcIikuYnVpbGRQb3NlaWRvbjtcblxuLy8gLyoqXG4vLyAgKiBDdXN0b20gcG9zZWlkb24gaGFzaCBmdW5jdGlvbiB0aGF0IGhhc2hlcyBzdHJpbmdzLlxuLy8gICogQHJldHVybnMge1Byb21pc2U8RnVuY3Rpb24+fSBwb3NlaWRvbiAtIFRoZSBwb3NlaWRvbiBoYXNoIGZ1bmN0aW9uLlxuLy8gICovXG4vLyBjb25zdCBidWlsZEN1c3RvbVBvc2VpZG9uID0gYXN5bmMgKCk6IFByb21pc2U8RnVuY3Rpb24+ID0+IHtcbi8vICAgICBjb25zdCBwb3NlaWRvbiA9IGF3YWl0IGJ1aWxkUG9zZWlkb24oKTtcbi8vICAgICByZXR1cm4gKHg6IHN0cmluZ1tdKSA9PiB7XG4vLyAgICAgICAgIGNvbnN0IGhhc2hTdHJpbmcgPSBwb3NlaWRvbi5GLnRvU3RyaW5nKHBvc2VpZG9uKHgpKTtcbi8vICAgICAgICAgLy8gY29uc29sZS5sb2cocGFyc2VJbnQoaGFzaFN0cmluZykudG9TdHJpbmcoMTYpKVxuLy8gICAgICAgICAvLyBjb25zdCBoZXhPZlN0cmluZyA9IEJ1ZmZlci5mcm9tKHgsICd1dGY4JykudG9TdHJpbmcoJ2hleCcpO1xuLy8gICAgICAgICAvLyBjb25zdCBiaWdJbnRPZlN0cmluZyA9IEJpZ0ludChcIjB4XCIgKyBoZXhPZlN0cmluZyk7XG4vLyAgICAgICAgIC8vIGNvbnN0IHBvc2VpZG9uSGFzaE91dHB1dCA9IHBvc2VpZG9uKFtiaWdJbnRPZlN0cmluZ10pO1xuLy8gICAgICAgICAvLyBjb25zb2xlLmxvZyhwb3NlaWRvbkhhc2hPdXRwdXQpO1xuLy8gICAgICAgICAvLyBjb25zb2xlLmxvZyhwYXJzZUludChwb3NlaWRvbi5GLnRvU3RyaW5nKHBvc2VpZG9uSGFzaE91dHB1dCkpLnRvU3RyaW5nKDE2KSlcbi8vICAgICAgICAgLy8gcmV0dXJuIHBvc2VpZG9uSGFzaE91dHB1dDtcbi8vICAgICAgICAgcmV0dXJuIGhhc2hTdHJpbmdcbi8vICAgICB9XG4vLyB9XG5cbi8qKiBcbiAqIEBmdW5jdGlvbjogc3RvcmVQb2xsXG4gKiBAZGVzY3JpcHRpb246IFRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhIG1lcmtsZSB0cmVlIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnNpZGUgb2YgdGhlIGRhdGFiYXNlLlxuICogQHJldHVybnMge0JpZ0ludH0gcm9vdCAtIFRoZSByb290IGhhc2ggb2YgdGhlIG1lcmtsZSB0cmVlIGNyZWF0ZWQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBwb2xsSWQgLSBUaGUgcG9sbCBpZCBvZiB0aGUgcG9sbCB0aGF0IHdhcyBjcmVhdGVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RvcmVQb2xsKHRpdGxlOiBzdHJpbmcsIGRlc2NyaXB0aW9uOiBzdHJpbmcsIGdyb3VwRGVzY3JpcHRpb246IHN0cmluZywgY3JlYXRlZEF0OiBudW1iZXIsIGRlYWRsaW5lOiBudW1iZXIsIGFkZHJlc3Nlczogc3RyaW5nW10pIHtcbiAgICB2YXIgdGl0bGUgPSB0aXRsZVxuICAgIHZhciBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uXG4gICAgdmFyIGdyb3VwRGVzY3JpcHRpb24gPSBncm91cERlc2NyaXB0aW9uXG4gICAgdmFyIGRhdGVDcmVhdGVkQXQgPSBuZXcgRGF0ZShjcmVhdGVkQXQpXG4gICAgdmFyIGRhdGVEZWFkbGluZSA9IG5ldyBEYXRlKGRlYWRsaW5lKVxuXG4gICAgLy8gVE9ETzogQ09ORklSTSBUSEFUIEFERFJFU1NFUyBBUkUgVkFMSUQgKE1vbGx5IHdpbGwgcHJvYnMgdGFrZSBjYXJlIG9mIHRoaXMpIFllcFxuXG4gICAgLy8gSW1wb3J0IHBvc2VpZG9uIGhhc2ggZnVuY3Rpb25cbiAgICBcbiAgICAvLyBjb25zdCBwb3NlaWRvbiA9IGF3YWl0IGJ1aWxkQ3VzdG9tUG9zZWlkb24oKTtcbiAgICAvLyBjb25zdCBwb3NlaWRvbiA9IGF3YWl0IGJ1aWxkUG9zZWlkb24oKTtcblxuICAgIC8vIEhhbmRsZXMgYXJiaXRyYXJ5IGlucHV0IVxuICAgIHZhciB0cmVlID0gYXdhaXQgYnVpbGRUcmVlUG9zZWlkb24oYWRkcmVzc2VzKVxuXG4gICAgY29uc29sZS5sb2codHJlZS5yb290KVxuXG4gICAgdmFyIHJvb3RTdHJpbmcgPSB0cmVlLnJvb3QudG9TdHJpbmcoKVxuXG4gICAgLy8gdmFyIHJvb3QgPSB0cmVlLmdldFJvb3QoKS50b1N0cmluZygnaGV4JylcblxuICAgIHZhciBwb2xsID0gYXdhaXQgcHJpc21hLnBvbGwuY3JlYXRlKHtcbiAgICAgICAgZGF0YSA6IHtcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGdyb3VwRGVzY3JpcHRpb246IGdyb3VwRGVzY3JpcHRpb24sXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IGRhdGVDcmVhdGVkQXQsXG4gICAgICAgICAgICBkZWFkbGluZTogZGF0ZURlYWRsaW5lLFxuICAgICAgICAgICAgdHJlZToge1xuICAgICAgICAgICAgICAgIGNyZWF0ZToge1xuICAgICAgICAgICAgICAgICAgICByb290SGFzaDogcm9vdFN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgbGVhdmVzOiBhZGRyZXNzZXMsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIC8vIFRPRE86IENPTlRSQUNUIENBTEwgVE8gQ1JFQVRFIFBPTEwgSU4gQ09OVFJBQ1RcblxuICAgIC8vIGNvbnN0IGFsbFBvbGxzID0gYXdhaXQgcHJpc21hLnBvbGwuZmluZE1hbnkoe1xuICAgIC8vICAgICBpbmNsdWRlOiB7XG4gICAgLy8gICAgICAgdHJlZTogdHJ1ZSxcbiAgICAvLyAgICAgfSxcbiAgICAvLyB9KVxuICAgIC8vIFByaW50IGFsbCBwb2xscyFcbiAgICAvLyBjb25zb2xlLmRpcihhbGxQb2xscywgeyBkZXB0aDogbnVsbCB9KVxuXG4gICAgcmV0dXJuIHtyb290SGFzaDogcm9vdFN0cmluZywgcG9sbElkOiBwb2xsLmlkfVxufVxuXG4vKiogXG4gKiBAZnVuY3Rpb246IHZlcmlmeUFkZHJlc3NJblRyZWVcbiAqIEBkZXNjcmlwdGlvbjogVGhpcyBmdW5jdGlvbiB2ZXJpZmllcyBpZiBhbiBhZGRyZXNzIGlzIGluIGEgbWVya2xlIHRyZWUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaXNWYWxpZFBvbGxJZCAtIFdoZXRoZXIgb3Igbm90IHRoZSBwb2xsIGlkIGlzIHZhbGlkLlxuICogQHJldHVybnMge251bWJlcn0gaW5UcmVlIC0gV2hldGhlciBvciBub3QgdGhlIGFkZHJlc3MgaXMgaW4gdGhlIHRyZWUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlBZGRyZXNzSW5UcmVlKGFkZHJlc3M6IHN0cmluZywgcG9sbElkOiBudW1iZXIpIHtcblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRUcmVlRnJvbVBvbGxJZChwb2xsSWQpXG4gICAgaWYgKGRhdGEudHJlZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7aXNWYWxpZFBvbGxJZDogZmFsc2UsIGluVHJlZTogZmFsc2V9XG4gICAgfVxuICAgIHZhciB0cmVlID0gZGF0YS50cmVlO1xuICAgIHZhciBtZXJrbGVUcmVlID0gYXdhaXQgYnVpbGRUcmVlUG9zZWlkb24odHJlZS5sZWF2ZXMpXG4gICAgdmFyIEJpZ0ludEFkZHJlc3MgPSBCaWdJbnQoYWRkcmVzcykudG9TdHJpbmcoKVxuICAgIHZhciBpblRyZWUgPSBhd2FpdCB2ZXJpZnlJblRyZWUobWVya2xlVHJlZS5yb290LnRvU3RyaW5nKCksIGFkZHJlc3MsIG1lcmtsZVRyZWUubGVhZlRvUGF0aEVsZW1lbnRzW0JpZ0ludEFkZHJlc3NdLCBtZXJrbGVUcmVlLmxlYWZUb1BhdGhJbmRpY2VzW0JpZ0ludEFkZHJlc3NdKVxuICAgIC8vIGNvbnNvbGUubG9nKFwiaW5UcmVlXCIsIGluVHJlZSlcbiAgICAvLyB2YXIgaW5UcmVlID0gbWVya2xlVHJlZS52ZXJpZnkocHJvb2YsIGFkZHJlc3MsIG1lcmtsZVRyZWUuZ2V0Um9vdCgpKVxuICAgIHJldHVybiB7aXNWYWxpZFBvbGxJZDogdHJ1ZSwgaW5UcmVlOiBpblRyZWV9XG59XG5cbi8qKiBcbiAqIEBmdW5jdGlvbjogZ2V0U2libGluZ3NBbmRQYXRoSW5kaWNlc1xuICogQGRlc2NyaXB0aW9uOiBUaGlzIGZ1bmN0aW9uIGdldHMgdGhlIHNpYmxpbmdzIGFuZCBwYXRoIGluZGljZXMgb2YgYW4gYWRkcmVzcyBpbiBhIG1lcmtsZSB0cmVlIGZvciB0aGUgdmVyaWZpZXIgJiBnZW5lcmF0b3IuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaXNWYWxpZFBvbGxJZCAtIFdoZXRoZXIgb3Igbm90IHRoZSBwb2xsIGlkIGlzIHZhbGlkLlxuICogQHJldHVybnMge1tdc3RyaW5nfSBzaWJsaW5ncyAtIFRoZSBzaWJsaW5ncyBvZiB0aGUgYWRkcmVzcyBpbiB0aGUgbWVya2xlIHRyZWUuXG4gKiBAcmV0dXJucyB7W11udW1iZXJ9IHBhdGhJbmRpY2VzIC0gVGhlIHBhdGggaW5kaWNlcyBvZiB0aGUgc2libGluZ3MgezAsIDF9IChzaWJsaW5nIG9uIHJpZ2h0LCBzaWJsaW5nIG9uIGxlZnQpLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2libGluZ3NBbmRQYXRoSW5kaWNlcyhhZGRyZXNzOiBzdHJpbmcsIHBvbGxJZDogbnVtYmVyKSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldFRyZWVGcm9tUG9sbElkKHBvbGxJZClcbiAgICBpZiAoZGF0YS50cmVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHtpc1ZhbGlkUG9sbElkOiBmYWxzZSwgc2libGluZ3M6IFtdLCBwYXRoSW5kaWNlczogW119XG4gICAgfVxuICAgIHZhciB0cmVlID0gZGF0YS50cmVlO1xuICAgIHZhciBtZXJrbGVUcmVlID0gYXdhaXQgYnVpbGRUcmVlUG9zZWlkb24odHJlZS5sZWF2ZXMpXG4gICAgY29uc29sZS5sb2cobWVya2xlVHJlZS5sZWFmVG9QYXRoRWxlbWVudHMpXG4gICAgY29uc29sZS5sb2cobWVya2xlVHJlZS5sZWFmVG9QYXRoSW5kaWNlcylcblxuXG4gICAgLy8gY29uc3QgcHJvb2YgPSBtZXJrbGVUcmVlLmdldFByb29mKGFkZHJlc3MpXG4gICAgLy8gdmFyIHNpYmxpbmdzID0gW11cbiAgICAvLyB2YXIgcGF0aEluZGljZXMgPSBbXVxuICAgIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvb2YubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAgICAgdmFyIHNpYmxpbmdIYXNoID0gcHJvb2ZbaV0uZGF0YS50b1N0cmluZygnaGV4JylcbiAgICAvLyAgICAgc2libGluZ3MucHVzaChzaWJsaW5nSGFzaClcbiAgICAvLyAgICAgLy8gSWYgbGVmdCAwLCBpZiByaWdodCAxXG4gICAgLy8gICAgIHZhciBwYXRoSW5kZXggPSBwcm9vZltpXS5wb3NpdGlvbiA9PSAnbGVmdCcgPyAxIDogMFxuICAgIC8vICAgICBwYXRoSW5kaWNlcy5wdXNoKHBhdGhJbmRleClcbiAgICAvLyB9XG4gICAgXG4gICAgdmFyIHNpYmxpbmdzID0gW11cbiAgICAvLyBjb25zb2xlLmxvZyhhd2FpdCBtZXJrbGVUcmVlLmxlYWZUb1BhdGhJbmRpY2VzLmxlbmd0aClcbiAgICAvLyBjb25zb2xlLmxvZyhtZXJrbGVUcmVlLmxlYWZUb1BhdGhFbGVtZW50c1thZGRyZXNzXSlcbiAgICB2YXIgQmlnSW50QWRkcmVzcyA9IEJpZ0ludChhZGRyZXNzKS50b1N0cmluZygpXG4gICAgY29uc29sZS5sb2coQmlnSW50QWRkcmVzcylcbiAgICB2YXIgQmlnSW50U2libGluZ3MgPSBtZXJrbGVUcmVlLmxlYWZUb1BhdGhFbGVtZW50c1tCaWdJbnRBZGRyZXNzXVxuICAgIGNvbnNvbGUubG9nKEJpZ0ludFNpYmxpbmdzKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQmlnSW50U2libGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNpYmxpbmdzLnB1c2goQmlnSW50U2libGluZ3NbaV0udG9TdHJpbmcoKSlcbiAgICB9XG4gICAgcmV0dXJuIHtpc1ZhbGlkUG9sbElkOiB0cnVlLCBzaWJsaW5nczogc2libGluZ3MsIHBhdGhJbmRpY2VzOiBtZXJrbGVUcmVlLmxlYWZUb1BhdGhJbmRpY2VzW0JpZ0ludEFkZHJlc3NdfVxufVxuXG4vKiogXG4gKiBAZnVuY3Rpb246IGdldFNpYmxpbmdzQW5kUGF0aEluZGljZXNcbiAqIEBkZXNjcmlwdGlvbjogVGhpcyBmdW5jdGlvbiBnZXRzIHRoZSBzaWJsaW5ncyBhbmQgcGF0aCBpbmRpY2VzIG9mIGFuIGFkZHJlc3MgaW4gYSBtZXJrbGUgdHJlZSBmb3IgdGhlIHZlcmlmaWVyICYgZ2VuZXJhdG9yLlxuICogQHJldHVybnMge251bWJlcn0gcG9sbElkIC0gUG9sbCBpZCBvZiB0aGUgcG9sbCB0aGF0IHdhcyBjcmVhdGVkLlxuICogQHJldHVybnMge1tdc3RyaW5nfSB0cmVlIC0gVGhlIG1lcmtsZSB0cmVlIHRoYXQgd2FzIGNyZWF0ZWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFRyZWVGcm9tUG9sbElkKHBvbGxJZDogbnVtYmVyKSB7XG5cbiAgICBjb25zdCB0cmVlID0gYXdhaXQgcHJpc21hLm1lcmtsZVRyZWUuZmluZFVuaXF1ZSh7XG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICBpZDogcG9sbElkXG4gICAgICAgIH0sXG4gICAgfSlcbiAgICAvLyBQcmludCBhbGwgcG9sbHMhXG4gICAgLy8gY29uc29sZS5kaXIodHJlZSwgeyBkZXB0aDogbnVsbCB9KVxuXG4gICAgcmV0dXJuIHt0cmVlOiB0cmVlLCBwb2xsSWQ6IHBvbGxJZH1cbn0iXSwibmFtZXMiOlsicHJpc21hIiwiYnVpbGRUcmVlUG9zZWlkb24iLCJ2ZXJpZnlJblRyZWUiLCJzdG9yZVBvbGwiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwiZ3JvdXBEZXNjcmlwdGlvbiIsImNyZWF0ZWRBdCIsImRlYWRsaW5lIiwiYWRkcmVzc2VzIiwiZGF0ZUNyZWF0ZWRBdCIsIkRhdGUiLCJkYXRlRGVhZGxpbmUiLCJ0cmVlIiwiY29uc29sZSIsImxvZyIsInJvb3QiLCJyb290U3RyaW5nIiwidG9TdHJpbmciLCJwb2xsIiwiY3JlYXRlIiwiZGF0YSIsInJvb3RIYXNoIiwibGVhdmVzIiwicG9sbElkIiwiaWQiLCJ2ZXJpZnlBZGRyZXNzSW5UcmVlIiwiYWRkcmVzcyIsImdldFRyZWVGcm9tUG9sbElkIiwiaXNWYWxpZFBvbGxJZCIsImluVHJlZSIsIm1lcmtsZVRyZWUiLCJCaWdJbnRBZGRyZXNzIiwiQmlnSW50IiwibGVhZlRvUGF0aEVsZW1lbnRzIiwibGVhZlRvUGF0aEluZGljZXMiLCJnZXRTaWJsaW5nc0FuZFBhdGhJbmRpY2VzIiwic2libGluZ3MiLCJwYXRoSW5kaWNlcyIsIkJpZ0ludFNpYmxpbmdzIiwiaSIsImxlbmd0aCIsInB1c2giLCJmaW5kVW5pcXVlIiwid2hlcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./pages/api/helpers/merkle.ts\n");

/***/ }),

/***/ "(api)/./pages/api/helpers/merklePoseidon.ts":
/*!*********************************************!*\
  !*** ./pages/api/helpers/merklePoseidon.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buildTreePoseidon\": () => (/* binding */ buildTreePoseidon),\n/* harmony export */   \"verifyInTree\": () => (/* binding */ verifyInTree)\n/* harmony export */ });\n// NOTE: copied from personaelabs/data because I(@lsankar4033) don't know how to npm typescript\nconst buildPoseidon = (__webpack_require__(/*! circomlibjs */ \"circomlibjs\").buildPoseidon);\n\nvar poseidon;\nlet F; // NOTE: picked this as the null field element arbitrarily\n\nconst NULL_NODE = 1n;\n\nasync function verifyInTree(root, address, siblings, pathIndices) {\n  poseidon = await buildPoseidon();\n  F = poseidon.F;\n  const rootBigInt = BigInt(root);\n  console.log(rootBigInt);\n  const addressBigInt = BigInt(address);\n  const siblingsBigInt = siblings.map(BigInt); // console.log(siblingsBigInt)\n\n  const pathIndicesBigInt = pathIndices.map(BigInt); // console.log(pathIndicesBigInt)\n\n  let curHash = addressBigInt;\n  console.log(\"Cur Hash: \", curHash);\n\n  for (let i = 0; i < siblingsBigInt.length; i++) {\n    if (pathIndicesBigInt[i] === 0n) {\n      curHash = F.toObject(poseidon([curHash, siblingsBigInt[i]]));\n    } else {\n      curHash = F.toObject(poseidon([siblingsBigInt[i], curHash]));\n    }\n\n    console.log(\"Cur Hash: \", curHash);\n  }\n\n  var isEqual = curHash.toString() == rootBigInt.toString();\n  return isEqual;\n} // NOTE: default tree depth based on dao hack confessions\n\n\nasync function buildTreePoseidon(leaves, depth = 16, proof_depth = 16, nullNode = NULL_NODE) {\n  //   if (!poseidon) {\n  //     poseidon = await buildPoseidon();\n  //     F = poseidon.F;\n  //   }\n  poseidon = await buildPoseidon();\n  F = poseidon.F; // pad with nullNode to guarantee a tree of the desired depth\n\n  const requiredLeaves = 2 ** depth;\n\n  if (leaves.length < requiredLeaves) {\n    leaves = leaves.concat(Array(requiredLeaves - leaves.length).fill(nullNode));\n  }\n\n  leaves = leaves.map(BigInt);\n  leaves.sort(); // the equivalent of pathElements and pathIndices in merkle.circom\n\n  const outputLeaves = leaves.filter(w => w !== nullNode); // console.log(outputLeaves)\n\n  let leafToPathElements = Object.fromEntries(outputLeaves.map(w => [w, []]));\n  let leafToPathIndices = Object.fromEntries(outputLeaves.map(w => [w, []]));\n  let nodeToLeaves = Object.fromEntries(leaves.map(w => [w, [w]]));\n  let curLevel = leaves;\n\n  while (curLevel.length > 1) {\n    let newLevel = [];\n\n    for (let i = 0; i < curLevel.length; i += 2) {\n      // console.log(curLevel[i])\n      let child1 = curLevel[i];\n      let child2 = i == curLevel.length - 1 ? nullNode : curLevel[i + 1];\n      let child1Leaves = nodeToLeaves[child1];\n      let child2Leaves = child2 == nullNode ? [] : nodeToLeaves[child2];\n\n      for (const leaf of child1Leaves) {\n        if (leaf !== nullNode) {\n          leafToPathElements[leaf].push(child2);\n          leafToPathIndices[leaf].push(\"0\");\n        }\n      }\n\n      for (const leaf of child2Leaves) {\n        if (leaf !== nullNode) {\n          leafToPathElements[leaf].push(child1);\n          leafToPathIndices[leaf].push(\"1\");\n        }\n      }\n\n      let poseidonRes = poseidon([child1, child2]);\n      let parent = F.toObject(poseidonRes);\n      nodeToLeaves[parent] = child1Leaves.concat(child2Leaves);\n      newLevel.push(parent);\n    }\n\n    curLevel = newLevel;\n  }\n\n  for (const leaf in leafToPathElements) {\n    while (leafToPathElements[leaf].length < proof_depth) {\n      leafToPathElements[leaf].push(nullNode);\n      leafToPathIndices[leaf].push(\"0\");\n    }\n  }\n\n  return {\n    root: curLevel[0],\n    leafToPathElements,\n    leafToPathIndices\n  };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9wYWdlcy9hcGkvaGVscGVycy9tZXJrbGVQb3NlaWRvbi50cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBRUEsTUFBTUEsYUFBYSxHQUFHQyxxRUFBdEI7O0FBRUEsSUFBSUMsUUFBSjtBQUNBLElBQUlDLENBQUosRUFFQTs7QUFDQSxNQUFNQyxTQUFTLEdBQUcsRUFBbEI7O0FBQ0EsZUFBZUMsWUFBZixDQUNJQyxJQURKLEVBRUlDLE9BRkosRUFHSUMsUUFISixFQUlJQyxXQUpKLEVBS0U7RUFDRVAsUUFBUSxHQUFHLE1BQU1GLGFBQWEsRUFBOUI7RUFDQUcsQ0FBQyxHQUFHRCxRQUFRLENBQUNDLENBQWI7RUFDQSxNQUFNTyxVQUFVLEdBQUdDLE1BQU0sQ0FBQ0wsSUFBRCxDQUF6QjtFQUNBTSxPQUFPLENBQUNDLEdBQVIsQ0FBWUgsVUFBWjtFQUNBLE1BQU1JLGFBQWEsR0FBR0gsTUFBTSxDQUFDSixPQUFELENBQTVCO0VBQ0EsTUFBTVEsY0FBYyxHQUFHUCxRQUFRLENBQUNRLEdBQVQsQ0FBYUwsTUFBYixDQUF2QixDQU5GLENBT0U7O0VBQ0EsTUFBTU0saUJBQWlCLEdBQUdSLFdBQVcsQ0FBQ08sR0FBWixDQUFnQkwsTUFBaEIsQ0FBMUIsQ0FSRixDQVNFOztFQUVBLElBQUlPLE9BQU8sR0FBR0osYUFBZDtFQUNBRixPQUFPLENBQUNDLEdBQVIsQ0FBWSxZQUFaLEVBQTBCSyxPQUExQjs7RUFDQSxLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdKLGNBQWMsQ0FBQ0ssTUFBbkMsRUFBMkNELENBQUMsRUFBNUMsRUFBZ0Q7SUFDNUMsSUFBSUYsaUJBQWlCLENBQUNFLENBQUQsQ0FBakIsS0FBeUIsRUFBN0IsRUFBaUM7TUFDN0JELE9BQU8sR0FBR2YsQ0FBQyxDQUFDa0IsUUFBRixDQUFXbkIsUUFBUSxDQUFDLENBQUNnQixPQUFELEVBQVVILGNBQWMsQ0FBQ0ksQ0FBRCxDQUF4QixDQUFELENBQW5CLENBQVY7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cmNlcyI6WyJ3ZWJwYWNrOi8vc3JjLy4vcGFnZXMvYXBpL2hlbHBlcnMvbWVya2xlUG9zZWlkb24udHM/ZjUyMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBOT1RFOiBjb3BpZWQgZnJvbSBwZXJzb25hZWxhYnMvZGF0YSBiZWNhdXNlIEkoQGxzYW5rYXI0MDMzKSBkb24ndCBrbm93IGhvdyB0byBucG0gdHlwZXNjcmlwdFxuXG5jb25zdCBidWlsZFBvc2VpZG9uID0gcmVxdWlyZShcImNpcmNvbWxpYmpzXCIpLmJ1aWxkUG9zZWlkb247XG5cbnZhciBwb3NlaWRvbjtcbmxldCBGO1xuXG4vLyBOT1RFOiBwaWNrZWQgdGhpcyBhcyB0aGUgbnVsbCBmaWVsZCBlbGVtZW50IGFyYml0cmFyaWx5XG5jb25zdCBOVUxMX05PREUgPSAxbjtcbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeUluVHJlZShcbiAgICByb290OiBzdHJpbmcsXG4gICAgYWRkcmVzczogc3RyaW5nLFxuICAgIHNpYmxpbmdzOiBzdHJpbmdbXSxcbiAgICBwYXRoSW5kaWNlczogc3RyaW5nW10sXG4pIHtcbiAgICBwb3NlaWRvbiA9IGF3YWl0IGJ1aWxkUG9zZWlkb24oKTtcbiAgICBGID0gcG9zZWlkb24uRjtcbiAgICBjb25zdCByb290QmlnSW50ID0gQmlnSW50KHJvb3QpO1xuICAgIGNvbnNvbGUubG9nKHJvb3RCaWdJbnQpXG4gICAgY29uc3QgYWRkcmVzc0JpZ0ludCA9IEJpZ0ludChhZGRyZXNzKTtcbiAgICBjb25zdCBzaWJsaW5nc0JpZ0ludCA9IHNpYmxpbmdzLm1hcChCaWdJbnQpO1xuICAgIC8vIGNvbnNvbGUubG9nKHNpYmxpbmdzQmlnSW50KVxuICAgIGNvbnN0IHBhdGhJbmRpY2VzQmlnSW50ID0gcGF0aEluZGljZXMubWFwKEJpZ0ludCk7XG4gICAgLy8gY29uc29sZS5sb2cocGF0aEluZGljZXNCaWdJbnQpXG5cbiAgICBsZXQgY3VySGFzaCA9IGFkZHJlc3NCaWdJbnQ7XG4gICAgY29uc29sZS5sb2coXCJDdXIgSGFzaDogXCIsIGN1ckhhc2gpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWJsaW5nc0JpZ0ludC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGF0aEluZGljZXNCaWdJbnRbaV0gPT09IDBuKSB7XG4gICAgICAgICAgICBjdXJIYXNoID0gRi50b09iamVjdChwb3NlaWRvbihbY3VySGFzaCwgc2libGluZ3NCaWdJbnRbaV1dKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJIYXNoID0gRi50b09iamVjdChwb3NlaWRvbihbc2libGluZ3NCaWdJbnRbaV0sIGN1ckhhc2hdKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coXCJDdXIgSGFzaDogXCIsIGN1ckhhc2gpXG4gICAgfVxuICAgIHZhciBpc0VxdWFsID0gY3VySGFzaC50b1N0cmluZygpID09IHJvb3RCaWdJbnQudG9TdHJpbmcoKVxuICAgIHJldHVybiBpc0VxdWFsO1xufVxuXG4vLyBOT1RFOiBkZWZhdWx0IHRyZWUgZGVwdGggYmFzZWQgb24gZGFvIGhhY2sgY29uZmVzc2lvbnNcbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkVHJlZVBvc2VpZG9uKFxuICAgIGxlYXZlczogYW55LFxuICAgIGRlcHRoID0gMTYsXG4gICAgcHJvb2ZfZGVwdGggPSAxNiwgICAgICAgICAgIFxuICAgIG51bGxOb2RlID0gTlVMTF9OT0RFXG4gICAgKSB7XG4gICAgLy8gICBpZiAoIXBvc2VpZG9uKSB7XG4gICAgLy8gICAgIHBvc2VpZG9uID0gYXdhaXQgYnVpbGRQb3NlaWRvbigpO1xuICAgIC8vICAgICBGID0gcG9zZWlkb24uRjtcbiAgICAvLyAgIH1cbiAgICBwb3NlaWRvbiA9IGF3YWl0IGJ1aWxkUG9zZWlkb24oKTtcbiAgICBGID0gcG9zZWlkb24uRjtcbiAgICAvLyBwYWQgd2l0aCBudWxsTm9kZSB0byBndWFyYW50ZWUgYSB0cmVlIG9mIHRoZSBkZXNpcmVkIGRlcHRoXG4gICAgY29uc3QgcmVxdWlyZWRMZWF2ZXMgPSAyICoqIGRlcHRoO1xuICAgIGlmIChsZWF2ZXMubGVuZ3RoIDwgcmVxdWlyZWRMZWF2ZXMpIHtcbiAgICAgICAgbGVhdmVzID0gbGVhdmVzLmNvbmNhdChcbiAgICAgICAgQXJyYXkocmVxdWlyZWRMZWF2ZXMgLSBsZWF2ZXMubGVuZ3RoKS5maWxsKG51bGxOb2RlKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGxlYXZlcyA9IGxlYXZlcy5tYXAoQmlnSW50KTtcbiAgICBsZWF2ZXMuc29ydCgpO1xuXG4gICAgLy8gdGhlIGVxdWl2YWxlbnQgb2YgcGF0aEVsZW1lbnRzIGFuZCBwYXRoSW5kaWNlcyBpbiBtZXJrbGUuY2lyY29tXG4gICAgY29uc3Qgb3V0cHV0TGVhdmVzID0gbGVhdmVzLmZpbHRlcigodzogYW55KSA9PiB3ICE9PSBudWxsTm9kZSk7XG4gICAgLy8gY29uc29sZS5sb2cob3V0cHV0TGVhdmVzKVxuICAgIGxldCBsZWFmVG9QYXRoRWxlbWVudHMgPSBPYmplY3QuZnJvbUVudHJpZXMob3V0cHV0TGVhdmVzLm1hcCgodzogYW55KSA9PiBbdywgW11dKSk7XG4gICAgbGV0IGxlYWZUb1BhdGhJbmRpY2VzID0gT2JqZWN0LmZyb21FbnRyaWVzKG91dHB1dExlYXZlcy5tYXAoKHc6IGFueSkgPT4gW3csIFtdXSkpO1xuXG4gICAgbGV0IG5vZGVUb0xlYXZlcyA9IE9iamVjdC5mcm9tRW50cmllcyhsZWF2ZXMubWFwKCh3OiBhbnkpID0+IFt3LCBbd11dKSk7XG4gICAgbGV0IGN1ckxldmVsID0gbGVhdmVzO1xuICAgIHdoaWxlIChjdXJMZXZlbC5sZW5ndGggPiAxKSB7XG4gICAgICAgIGxldCBuZXdMZXZlbCA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyTGV2ZWwubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGN1ckxldmVsW2ldKVxuICAgICAgICAgICAgbGV0IGNoaWxkMSA9IGN1ckxldmVsW2ldO1xuICAgICAgICAgICAgbGV0IGNoaWxkMiA9IGkgPT0gY3VyTGV2ZWwubGVuZ3RoIC0gMSA/IG51bGxOb2RlIDogY3VyTGV2ZWxbaSArIDFdO1xuXG4gICAgICAgICAgICBsZXQgY2hpbGQxTGVhdmVzID0gbm9kZVRvTGVhdmVzW2NoaWxkMV07XG4gICAgICAgICAgICBsZXQgY2hpbGQyTGVhdmVzID0gY2hpbGQyID09IG51bGxOb2RlID8gW10gOiBub2RlVG9MZWF2ZXNbY2hpbGQyXTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBsZWFmIG9mIGNoaWxkMUxlYXZlcykge1xuICAgICAgICAgICAgICAgIGlmIChsZWFmICE9PSBudWxsTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBsZWFmVG9QYXRoRWxlbWVudHNbbGVhZl0ucHVzaChjaGlsZDIpO1xuICAgICAgICAgICAgICAgICAgICBsZWFmVG9QYXRoSW5kaWNlc1tsZWFmXS5wdXNoKFwiMFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgbGVhZiBvZiBjaGlsZDJMZWF2ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVhZiAhPT0gbnVsbE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVhZlRvUGF0aEVsZW1lbnRzW2xlYWZdLnB1c2goY2hpbGQxKTtcbiAgICAgICAgICAgICAgICAgICAgbGVhZlRvUGF0aEluZGljZXNbbGVhZl0ucHVzaChcIjFcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcG9zZWlkb25SZXMgPSBwb3NlaWRvbihbY2hpbGQxLCBjaGlsZDJdKTtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBGLnRvT2JqZWN0KHBvc2VpZG9uUmVzKTtcblxuICAgICAgICAgICAgbm9kZVRvTGVhdmVzW3BhcmVudF0gPSBjaGlsZDFMZWF2ZXMuY29uY2F0KGNoaWxkMkxlYXZlcyk7XG5cbiAgICAgICAgICAgIG5ld0xldmVsLnB1c2gocGFyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1ckxldmVsID0gbmV3TGV2ZWw7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBsZWFmIGluIGxlYWZUb1BhdGhFbGVtZW50cykge1xuICAgICAgICB3aGlsZSAobGVhZlRvUGF0aEVsZW1lbnRzW2xlYWZdLmxlbmd0aCA8IHByb29mX2RlcHRoKSB7XG4gICAgICAgICAgICBsZWFmVG9QYXRoRWxlbWVudHNbbGVhZl0ucHVzaChudWxsTm9kZSk7XG4gICAgICAgICAgICBsZWFmVG9QYXRoSW5kaWNlc1tsZWFmXS5wdXNoKFwiMFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHJvb3Q6IGN1ckxldmVsWzBdLFxuICAgICAgICBsZWFmVG9QYXRoRWxlbWVudHMsXG4gICAgICAgIGxlYWZUb1BhdGhJbmRpY2VzLFxuICAgIH07XG59XG5cbmV4cG9ydCB7IGJ1aWxkVHJlZVBvc2VpZG9uLCB2ZXJpZnlJblRyZWUgfTsiXSwibmFtZXMiOlsiYnVpbGRQb3NlaWRvbiIsInJlcXVpcmUiLCJwb3NlaWRvbiIsIkYiLCJOVUxMX05PREUiLCJ2ZXJpZnlJblRyZWUiLCJyb290IiwiYWRkcmVzcyIsInNpYmxpbmdzIiwicGF0aEluZGljZXMiLCJyb290QmlnSW50IiwiQmlnSW50IiwiY29uc29sZSIsImxvZyIsImFkZHJlc3NCaWdJbnQiLCJzaWJsaW5nc0JpZ0ludCIsIm1hcCIsInBhdGhJbmRpY2VzQmlnSW50IiwiY3VySGFzaCIsImkiLCJsZW5ndGgiLCJ0b09iamVjdCIsImlzRXF1YWwiLCJ0b1N0cmluZyIsImJ1aWxkVHJlZVBvc2VpZG9uIiwibGVhdmVzIiwiZGVwdGgiLCJwcm9vZl9kZXB0aCIsIm51bGxOb2RlIiwicmVxdWlyZWRMZWF2ZXMiLCJjb25jYXQiLCJBcnJheSIsImZpbGwiLCJzb3J0Iiwib3V0cHV0TGVhdmVzIiwiZmlsdGVyIiwidyIsImxlYWZUb1BhdGhFbGVtZW50cyIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwibGVhZlRvUGF0aEluZGljZXMiLCJub2RlVG9MZWF2ZXMiLCJjdXJMZXZlbCIsIm5ld0xldmVsIiwiY2hpbGQxIiwiY2hpbGQyIiwiY2hpbGQxTGVhdmVzIiwiY2hpbGQyTGVhdmVzIiwibGVhZiIsInB1c2giLCJwb3NlaWRvblJlcyIsInBhcmVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./pages/api/helpers/merklePoseidon.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = (__webpack_exec__("(api)/./pages/api/generatePoll.ts"));
module.exports = __webpack_exports__;

})();